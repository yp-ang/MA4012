#pragma config(Sensor, in1,    ,               sensorAnalog)
#pragma config(Sensor, in2,    ,               sensorAnalog)
#pragma config(Sensor, in3,    ,               sensorAnalog)
#pragma config(Sensor, in4,    ,               sensorAnalog)
#pragma config(Sensor, in5,    ,               sensorAnalog)
#pragma config(Sensor, in6,    ,               sensorAnalog)
#pragma config(Sensor, in7,    ,               sensorAnalog)
#pragma config(Sensor, in8,    ,               sensorAnalog)
#pragma config(Sensor, dgtl1,  ,               sensorDigitalIn)
#pragma config(Sensor, dgtl2,  ,               sensorDigitalIn)
#pragma config(Sensor, dgtl3,  ,               sensorDigitalIn)
#pragma config(Sensor, dgtl4,  ,               sensorDigitalIn)
#pragma config(Sensor, dgtl5,  ,               sensorDigitalIn)
#pragma config(Sensor, dgtl6,  ,               sensorDigitalIn)
#pragma config(Sensor, dgtl7,  ,               sensorDigitalIn)
#pragma config(Sensor, dgtl8,  ,               sensorDigitalIn)
#pragma config(Sensor, dgtl9,  ,               sensorDigitalIn)
#pragma config(Sensor, dgtl10, ,               sensorDigitalIn)
#pragma config(Sensor, dgtl11, ,               sensorDigitalIn)
#pragma config(Sensor, dgtl12, ,               sensorDigitalIn)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// EVERYTHING DISTANCE RELATED IN mm!
// Motor Definitions
// 2500 at 24 pwm for half a circle

#define LEFT_MOT_PORT port3
#define RIGHT_MOT_PORT port5
#define DOOR_MOT_PORT port4
#define ROLLER_MOT_PORT port2
#define DOOR_MOT_SPEED 50
#define SPEED_OFFSET 0.0
#define SLOW_SPEED 20.0
#define OP_SPEED 127.0

// Limit Switch Definitions
#define DOOR_LSWITCH_PORT dgtl11 // switch pressed down is 1
#define BALL_LSWITCH_PORT dgtl12 //switch pressed down is 1
#define BACK_L_LSWITCH_PORT dgtl9 //switch pressed down is 0
#define BACK_R_LSWITCH_PORT dgtl10 //switch pressed down is 0

// Start Switch Definitions
#define START_SWITCH_PORT dgtl8 // switch on is 0

// Distance IR Sensor Definitions
#define RIGHT_DIST_IR_TYPE ORANGE_GREEN
#define TOP_DIST_IR_PORT in1
#define LEFT_DIST_IR_TYPE ORANGE_YELLOW
#define BTM_DIST_IR_PORT in2
#define CENTER_DIST_IR_TYPE ORANGE_PINK
#define CENTER_DIST_IR_PORT in3
#define DOOR_DIST_IR_TYPE ORANGE_BLUE
#define DOOR_DIST_IR_PORT in6
#define DOOR_DIST_IR_THRESHOLD 130.0 //in mm
#define DIST_IR_MAX_DIFF 68.0 //in mm
#define DIST_IR_MIN_DIFF 150.0 //in mm
#define LEFT_DIST_IR_OFFSET 70.0//

//Reflective Sensor Definitions
#define FRT_LFT_REFL_IR_PORT in4
#define FRT_RGT_REFL_IR_PORT in5
#define FRT_LFT_REFL_IR_THRESHOLD 1500
#define FRT_RGT_REFL_IR_THRESHOLD 1000
#define BCK_LFT_REFL_IR_PORT in7
#define BCK_RGT_REFL_IR_PORT in8
#define BCK_LFT_REFL_IR_THRESHOLD 2000
#define BCK_RGT_REFL_IR_THRESHOLD 800

//Compass Definitions
#define NORTH_PORT dgtl3
#define EAST_PORT dgtl4
#define SOUTH_PORT dgtl5
#define WEST_PORT dgtl6

// Utils
#define WIFI_DEBUGGING 0

//Only allow CALIBRATION or TESTING one at a time
#define CALIBRATION 0
//#define TESTING 0
#define UART_PORT uartOne
#define TIMER T1

enum ir_sensor
{
	ORANGE_PINK,
	ORANGE_GREEN,
	ORANGE_YELLOW,
	ORANGE_BLUE,
	NUMBER_OF_IR_SENSORS
};
enum direction
{
	STOP,
	REVERSE,
	STRAIGHT,
	CLOCKWISE,
	CCLOCKWISE,
	RIGHT_TURN,
	LEFT_TURN
};
enum bearing
{
	NORTH,
	NORTHEAST,
	EAST,
	SOUTHEAST,
	SOUTH,
	SOUTHWEST,
	WEST,
	NORTHWEST,
	ERROR
};
enum mode
{
	MOVE_TO_CENTER,
	SEARCH_FOR_BALL,
	MOVE_TO_BALL,
	RETURN_THE_BALL,
	RESET
};
enum search_ball_seq
{
	ROTATE,
	MOVE_TO_NEW_POSITION
};

enum move_to_ball_seq
{
	OFFSET,
	MOVE_TOWARDS_BALL
};
enum return_ball_seq
{
	ALIGN_BEARING,
	ALIGN_OFFSET,
	RETURN_TO_BASE,
	MOVE_FORWARD,
	TURN_RIGHT,
	MOVE_FORWARD_RIGHT,
	DEPOSIT_BALL
};

/*Thresholds are at 10-60cm as the anything above 60cm for the 10-80cm sensors is just too bad
For 4-30cm, threshold taken at 30cm
*/
int ir_sensor_max_value[(int) NUMBER_OF_IR_SENSORS] = {2000, 2000, 2000, 1978};
int ir_sensor_min_value[(int) NUMBER_OF_IR_SENSORS] = {508, 472, 476, 307};

mode machine_mode = MOVE_TO_CENTER;
search_ball_seq search_ball = ROTATE;
move_to_ball_seq move_ball = OFFSET;
return_ball_seq return_ball = ALIGN_BEARING;
bearing machine_heading = ERROR;
direction machine_direction = STOP;
direction prev_direction;
float btm_distance, top_distance, center_distance;
int machine_speed = 0;

void send_debug_msg(char *msg, int size)
{
#ifdef WIFI_DEBUGGING
	for (int i = 0; i < size; i++)
	{
		sendChar(UART_PORT, msg[i]);
	}
#endif
}

bool check_within_range(float value, float min, float max)
{
	return value <= min || value >= max ? false : true;
}

float convert_ir_reading_to_distance(ir_sensor sensor, int analog)
{
	switch (sensor)
	{
	case ORANGE_BLUE:
		//return 2316.4 * pow(analog, -0.998) * 10;
		break;
	case ORANGE_GREEN:
		//return (3 * pow(10, -12) * pow(analog, 4) - 2 * pow(10, -8) * pow(analog , 3) + 7 * pow(10, -5) * pow(analog, 2) - 0.1052 * analog + 70.476) * 10;
		return 28899.0 * pow(analog, -1.077) * 10;
		break;
	case ORANGE_PINK:
		//return (-0.0004 * pow(analog, 4.0) + 0.0191 * pow(analog, 3.0) + 1.6462 * pow(analog, 2.0)
		//- 113.29 * analog + 2533.4) * 10.0;
		return 18417.0 * pow(analog, -0.942) * 10;
		break;
	case ORANGE_YELLOW:
		//return (5 * pow(10, -12) * pow(analog, 4) - 4 * pow(10, -8) * pow(analog , 3) + 0.0001 * pow(analog, 2) - 0.1488 * analog + 87.392) * 10;
		return 28899.0 * pow(analog, -1.077) * 10;
	default:
		return -1;
	}
}

void movement(direction directionMode, int speed = 0)
{
	int speed1 = abs(speed * 1.02);
	switch (directionMode)
	{
	case STOP:
		motor[LEFT_MOT_PORT] = 0;
		motor[RIGHT_MOT_PORT] = 0;
		break;
	case REVERSE:
		motor[LEFT_MOT_PORT] = -speed;
		motor[RIGHT_MOT_PORT] = speed1;
		break;
	case STRAIGHT:
		motor[LEFT_MOT_PORT] = speed;
		motor[RIGHT_MOT_PORT] = -speed1;
		break;
	case CLOCKWISE:
		motor[LEFT_MOT_PORT] = speed;
		motor[RIGHT_MOT_PORT] = speed1;
		break;
	case CCLOCKWISE:
		motor[LEFT_MOT_PORT] = -speed;
		motor[RIGHT_MOT_PORT] = -speed1;
		break;
	case RIGHT_TURN:
		motor[LEFT_MOT_PORT] = speed;
		motor[RIGHT_MOT_PORT] = -speed1 * 0.5;
		break;
	case LEFT_TURN:
		motor[LEFT_MOT_PORT] = speed * 0.5;
		motor[RIGHT_MOT_PORT] = -speed1;
		break;
	default:
		motor[LEFT_MOT_PORT] = 0;
		motor[RIGHT_MOT_PORT] = 0;
		break;
	}
}

bool detect_ball_deposit()
{
	return SensorValue(BACK_L_LSWITCH_PORT) == 0 && SensorValue(BACK_R_LSWITCH_PORT) == 0;
}

int take_average(tSensors sensor_port, int readings)
{
	float average = 0;
	for (int i = 0; i < readings; i++)
	{
		average += SensorValue(sensor_port);
	}
	return average / readings;
}

enum bearing get_heading()
{
	int heading = 0;
	heading = heading + (SensorValue(NORTH_PORT) == 0) + (SensorValue(EAST_PORT) == 0) * 2 +
	(SensorValue(SOUTH_PORT) == 0) * 4 + (SensorValue(WEST_PORT) == 0) * 8;
	char buf[16];
	switch (heading)
	{
	case 1:
#ifdef WIFI_DEBUGGING
		snprintf(buf, sizeof(buf), "NORTH\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		return NORTH;
		break;
	case 3:

#ifdef WIFI_DEBUGGING
		snprintf(buf, sizeof(buf), "NORTHEAST\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		return NORTHEAST;
		break;
	case 2:

#ifdef WIFI_DEBUGGING
		snprintf(buf, sizeof(buf), "EAST\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		return EAST;
		break;
	case 6:

#ifdef WIFI_DEBUGGING
		snprintf(buf, sizeof(buf), "SOUTHEAST\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		return SOUTHEAST;
		break;
	case 4:

#ifdef WIFI_DEBUGGING
		snprintf(buf, sizeof(buf), "SOUTH\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		return SOUTH;
		break;
	case 12:

#ifdef WIFI_DEBUGGING
		snprintf(buf, sizeof(buf), "SOUTHWEST\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		return SOUTHWEST;
		break;
	case 8:

#ifdef WIFI_DEBUGGING
		snprintf(buf, sizeof(buf), "WEST\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		return WEST;
		break;
	case 9:
#ifdef WIFI_DEBUGGING
		snprintf(buf, sizeof(buf), "NORTHWEST\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		return NORTHWEST;
		break;
	default:
#ifdef WIFI_DEBUGGING
		snprintf(buf, sizeof(buf), "ERROR\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		return ERROR;
	}
}

bool detect_ballv4()
{
	bool result = false;
	static int count = 0;
	static int heading_count = 0;
	int left_analog = take_average(BTM_DIST_IR_PORT, 1);
	btm_distance = convert_ir_reading_to_distance(LEFT_DIST_IR_TYPE, left_analog);
	bool left_curr_in_range =
	check_within_range(btm_distance, 0, 400);
	int right_analog = take_average(TOP_DIST_IR_PORT, 1);
	top_distance = convert_ir_reading_to_distance(RIGHT_DIST_IR_TYPE, right_analog);
	bool right_curr_in_range =
	check_within_range(top_distance, 0, 400);
	int center_analog = take_average(CENTER_DIST_IR_PORT, 1);
	center_distance = convert_ir_reading_to_distance(CENTER_DIST_IR_TYPE, center_analog);
	bool center_curr_in_range =
	check_within_range(center_distance, 0, 500);

#ifdef WIFI_DEBUGGING
	char buf1[32];
	snprintf(buf1, sizeof(buf1), "Value: %.2f, %.2f, %.2f\n", btm_distance, top_distance, center_distance);
	send_debug_msg(buf1, sizeof(buf1));
#endif
	if (!left_curr_in_range && !right_curr_in_range)
	{
#ifdef WIFI_DEBUGGING
		char buf[16];
		snprintf(buf, sizeof(buf), "lft/rgt nir\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		result = false;
	}
	else if (left_curr_in_range && !right_curr_in_range)
	{
		if (!center_curr_in_range)
		{
#ifdef WIFI_DEBUGGING
			char buf[16];
			snprintf(buf, sizeof(buf), "lft ir, rgt nir\n");
			send_debug_msg(buf, sizeof(buf));
#endif
			result = true;
		}
		else
		{
			result = false;
		}

	}
	else if (right_curr_in_range && left_curr_in_range && !center_curr_in_range)
	{
		if ((top_distance - btm_distance) >= 90)
		{
#ifdef WIFI_DEBUGGING
			char buf[16];
			snprintf(buf, sizeof(buf), "lft/rgt bdiff\n");
			send_debug_msg(buf, sizeof(buf));
#endif
			result = true;
		}
		else
		{
#ifdef WIFI_DEBUGGING
			char buf[16];
			snprintf(buf, sizeof(buf), "lft/rgt sdiff\n");
			send_debug_msg(buf, sizeof(buf));
#endif
			//if (btm_distance <= 10.0)
			//{
			//evasive manuevers?
			//}
			result = false;
		}
	}
	else
	{
#ifdef WIFI_DEBUGGING
		char buf[16];
		snprintf(buf, sizeof(buf), "other cons\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		result = false;
	}
	if (result)
	{
		count = count + 1;
		if (count >= 3)
		{
			count = 0;
#ifdef WIFI_DEBUGGING
			char buf[16];
			snprintf(buf, sizeof(buf), "!!DETECTED!!!\n");
			send_debug_msg(buf, sizeof(buf));
#endif
			bearing measured_heading = get_heading();
			if (measured_heading == NORTH || measured_heading == NORTHEAST || measured_heading == NORTHWEST)
			{
				heading_count = heading_count + 1;
			}
			else
			{
				heading_count = 0;
			}
			if (heading_count >= 3)
			{
				heading_count = 0;
				machine_mode = RESET;
				return false;
			}
			return true;
		}
		return false;
	}
	count = 0;
	return false;
}

bool align_ball()
{
	int center_analog = take_average(CENTER_DIST_IR_PORT, 1);
	center_distance = convert_ir_reading_to_distance(CENTER_DIST_IR_TYPE, center_analog);
	float x = pow(120.0, 2);
	float y = pow(btm_distance + 140.0, 2.0);
	float distance = pow( x + y , 0.5);
#ifdef WIFI_DEBUGGING
	char buf5[24];
	snprintf(buf5, sizeof(buf5), "Al Val: %.2f, %.2f\n", center_distance, distance);
	send_debug_msg(buf5, sizeof(buf5));
#endif
	if ((center_distance + 70.0) <=  distance * 1.9) //0.9
	{
#ifdef WIFI_DEBUGGING
		char buf[16];
		snprintf(buf, sizeof(buf), "!!!ALIGNEDD!!\n");
		send_debug_msg(buf, sizeof(buf));
#endif
		return true;
	}
	return false;
}

bool detect_ball_collector()
{
	return (SensorValue(BALL_LSWITCH_PORT) == 1);
}

void keep_door_closed()
{
	motor[DOOR_MOT_PORT] = -1 * DOOR_MOT_SPEED * (SensorValue[DOOR_LSWITCH_PORT] == 0);
}

void goto_movetocenter()
{
	machine_mode = MOVE_TO_CENTER;
	machine_direction = STRAIGHT;
	machine_speed = 100;
	motor[ROLLER_MOT_PORT] = 127;
	clearTimer(TIMER);
}

void goto_searchforball()
{
	char buf[32];
	snprintf(buf, sizeof(buf), "Going to SEARCH_FOR_BALL\n");
	send_debug_msg(buf, sizeof(buf));
	machine_mode = SEARCH_FOR_BALL;
	search_ball = ROTATE;
	machine_direction = CCLOCKWISE;
	machine_speed = 24;
	motor[ROLLER_MOT_PORT] = 127;
	clearTimer(TIMER);
}

bool determine_rotation_direction()
{
	bearing current_heading = get_heading();
	if (current_heading == machine_heading)
	{
		prev_direction = machine_direction;
		machine_direction = CCLOCKWISE;
		return true;
	}
	else
	{
		if ((((int)current_heading + (8 - (int)machine_heading)) % 8) >= 4)
		{
			machine_direction = CLOCKWISE;
			machine_speed = 24;
#ifdef WIFI_DEBUGGING
			char buf[32];
			snprintf(buf, sizeof(buf), "CurrHd: %d, MacHd: %d, CLK\n", (int) current_heading, (int)machine_heading);
			send_debug_msg(buf, sizeof(buf));
#endif

		}
		else
		{
			machine_direction = CCLOCKWISE;
			machine_speed = 24;
#ifdef WIFI_DEBUGGING
			char buf[32];
			snprintf(buf, sizeof(buf), "CurrHd: %d, MacHd: %d, CCLK\n", (int) current_heading, (int)machine_heading);
			send_debug_msg(buf, sizeof(buf));
#endif
		}
	}
	return false;
}

void goto_returnball()
{
	char buf[24];
	snprintf(buf, sizeof(buf), "Going to RETURN_BALL\n");
	send_debug_msg(buf, sizeof(buf));
	machine_mode = RETURN_THE_BALL;
	return_ball = ALIGN_BEARING;
	determine_rotation_direction();
}

void run_machine()
{
	keep_door_closed();
	switch (machine_mode)
	{
	case MOVE_TO_CENTER:
		if (time1[TIMER] > 4000)
		{
			goto_searchforball();
		}
		if (detect_ballv4())
		{
			machine_mode = MOVE_TO_BALL;
			machine_direction = CLOCKWISE;
			machine_speed = 24;
			move_ball = OFFSET;
			clearTimer(TIMER);
			break;
		}
		if (detect_ball_collector())
		{
			goto_returnball();
			break;
		}
		break;
	case SEARCH_FOR_BALL:
		motor[ROLLER_MOT_PORT] = 127;
		if (detect_ball_collector())
		{
			goto_returnball();
			break;
		}
		if (detect_ballv4())
		{
			machine_mode = MOVE_TO_BALL;
			machine_direction = CLOCKWISE;
			machine_speed = 24;
			move_ball = OFFSET;
			clearTimer(TIMER);
			break;
		}
		switch (search_ball)
		{
		case ROTATE:
			if (time1[TIMER] > 4000)
			{
				send_debug_msg("Changing to MOVE_TO_NEW_POSITION", 48);
				machine_direction = STRAIGHT;
				machine_speed = 60;
				search_ball = MOVE_TO_NEW_POSITION;
				clearTimer(TIMER);
			}
			break;
		case MOVE_TO_NEW_POSITION:
			if (time1[TIMER] > 1000 )
			{
				send_debug_msg("Changing to ROTATE", 48);
				machine_direction = CCLOCKWISE;
				machine_speed = 24;
				search_ball = ROTATE;
				clearTimer(TIMER);
			}
			break;
		}
		break;
	case MOVE_TO_BALL:
		if (detect_ball_collector())
		{
			goto_returnball();
			break;
		}
		switch (move_ball)
		{
		case OFFSET:
			if (time1[TIMER] > 1500)
			{
				goto_searchforball();
			}
			if (align_ball())
			{
				move_ball = MOVE_TOWARDS_BALL;
				machine_direction = STRAIGHT;
				machine_speed = 60;
				clearTimer(TIMER);
			}
			break;
		case MOVE_TOWARDS_BALL:
			if (time1[TIMER] > 2000)
			{
				goto_searchforball();
			}
			if (detect_ball_collector())
			{
				goto_returnball();
				break;
			}
			break;
		}
		break;
	case RETURN_THE_BALL:
		motor[ROLLER_MOT_PORT] = -40;
		switch (return_ball)
		{
		case ALIGN_BEARING:
			if (determine_rotation_direction())
			{
				machine_direction = REVERSE;
				machine_speed = 127;
				return_ball = RETURN_TO_BASE;
				prev_direction = STOP;
				clearTimer(TIMER);
			}
			break;
		case RETURN_TO_BASE:
			{
				if (time1[TIMER] > 20000)
				{
					machine_direction = STRAIGHT;
					machine_speed = 127;
					return_ball = TURN_RIGHT;
					clearTimer(TIMER);
				}
				bearing measured_heading = get_heading();
				if (!(measured_heading == SOUTH || measured_heading == SOUTHEAST || measured_heading == SOUTHWEST))
				{
					goto_returnball();
					break;
				}
				if (detect_ball_deposit())
				{
					send_debug_msg("YIPEE2\n", 16);
					machine_direction = STOP;
					machine_speed = 0;
					return_ball = DEPOSIT_BALL;
					clearTimer(TIMER);
				}
			}
			break;
		case DEPOSIT_BALL:
			motor[DOOR_MOT_PORT] = DOOR_MOT_SPEED;
			if (time1[TIMER] > 200)
			{
				goto_movetocenter();
			}
			break;
		case MOVE_FORWARD:
			if (time1[TIMER] > 2000 )
			{
				machine_direction = CCLOCKWISE;
				machine_speed = 24;
				return_ball = TURN_RIGHT;
				clearTimer(TIMER);
			}
			break;
		case TURN_RIGHT:
			if (time1[TIMER] > 2000 )
			{
				machine_direction = STRAIGHT;
				machine_speed = 127;
				return_ball = MOVE_FORWARD_RIGHT;
				clearTimer(TIMER);
			}
			break;
		case MOVE_FORWARD_RIGHT:
			if (time1[TIMER] > 2000 )
			{
				goto_returnball();
			}
			break;
		}
		break;
	case RESET:
		if (determine_rotation_direction())
		{
			goto_movetocenter();
		}
		break;
	default:
		break;
	}
	movement(machine_direction, machine_speed);
}

void edge_detection()
{
	const int reverse_speed = 100;
	const int rotate_speed = 100;
	const int reverse_duration = 800;
	const int turn_duration = 200;
	const int turn_duration_reverse =400;
	bool frt_lft_detected = SensorValue(FRT_LFT_REFL_IR_PORT) <= FRT_LFT_REFL_IR_THRESHOLD;
	bool frt_rgt_detected = SensorValue(FRT_RGT_REFL_IR_PORT) <= FRT_RGT_REFL_IR_THRESHOLD;
	bool bck_lft_detected = SensorValue(BCK_LFT_REFL_IR_PORT) <= BCK_LFT_REFL_IR_THRESHOLD;
	bool bck_rgt_detected = SensorValue(BCK_RGT_REFL_IR_PORT) <= BCK_RGT_REFL_IR_THRESHOLD;
	if (frt_lft_detected)
	{
		movement(REVERSE, reverse_speed);
		delay(reverse_duration);
		movement(CLOCKWISE, rotate_speed);
		delay(turn_duration);
		send_debug_msg("front left detected\n", 32);
	}
	else if (frt_rgt_detected)
	{
		movement(REVERSE, reverse_speed);
		delay(reverse_duration);
		movement(CCLOCKWISE, rotate_speed);
		delay(turn_duration);
		send_debug_msg("front right detected\n", 32);
	}
	else if (bck_lft_detected)
	{
		if (machine_mode == RETURN_THE_BALL  && return_ball ==  RETURN_TO_BASE)
		{
			movement(STRAIGHT, reverse_speed);
			delay(reverse_duration - 100);
			movement(CCLOCKWISE, rotate_speed);
			delay(turn_duration_reverse + 100);
			send_debug_msg("back left detected\n", 32);
		}
		else
		{
			movement(STRAIGHT, reverse_speed);
			delay(reverse_duration);
			movement(CCLOCKWISE, rotate_speed);
			delay(turn_duration_reverse);
			send_debug_msg("back left detected\n", 32);
		}
	}
	else if (bck_rgt_detected)
	{
		if (machine_mode == RETURN_THE_BALL  && return_ball ==  RETURN_TO_BASE)
		{
			movement(STRAIGHT, reverse_speed);
			delay(reverse_duration - 100);
			movement(CLOCKWISE, rotate_speed);
			delay(turn_duration_reverse + 50);
			send_debug_msg("back right detected\n", 32);
		}
		else
		{
			movement(STRAIGHT, reverse_speed);
			delay(reverse_duration);
			movement(CLOCKWISE, rotate_speed);
			delay(turn_duration_reverse);
			send_debug_msg("back right detected\n", 32);
		}

	}
}

task runMachine()
{
	while (1)
	{
		edge_detection();
		run_machine();
		wait1Msec(20);
	}
}

//////////////////////////////////////////////////////////
task main()
{
#ifdef WIFI_DEBUGGING
	setBaudRate(UART_PORT, baudRate115200);
	send_debug_msg("Vex Started\n", 13);
	writeDebugStreamLine("%d", nImmediateBatteryLevel);
#endif
#ifdef CALIBRATION
	while (true)
	{
		//char buf[260];
		//snprintf(buf, sizeof(buf), "Btm Dist IR: %d\n Top Dist IR: %d\n Center Dist IR: %d\n"
		//"Front Left IR: %d\n Front Right IR: %d\n Back Left IR: %d\n Back Right IR: %d\n"
		//"Door Limit Switch: %d\n Ball Limit Switch: %d\n Back Left Limit Switch: %d\n Back Right Limit Switch: %d\n",
		//SensorValue(BTM_DIST_IR_PORT), SensorValue(TOP_DIST_IR_PORT), SensorValue(CENTER_DIST_IR_PORT),
		//SensorValue(FRT_LFT_REFL_IR_PORT), SensorValue(FRT_RGT_REFL_IR_PORT), SensorValue(BCK_LFT_REFL_IR_PORT), SensorValue(BCK_RGT_REFL_IR_PORT),
		//SensorValue(DOOR_LSWITCH_PORT), SensorValue(BALL_LSWITCH_PORT), SensorValue(BACK_L_LSWITCH_PORT), SensorValue(BACK_R_LSWITCH_PORT));
		//writeDebugStreamLine("%s\n", buf);
		//		int left_analog = take_average(BTM_DIST_IR_PORT, 1);
		//		btm_distance = convert_ir_reading_to_distance(LEFT_DIST_IR_TYPE, left_analog);
		//		lowest_reading = btm_distance;
		//		int right_analog = take_average(TOP_DIST_IR_PORT, 1);
		//		top_distance = convert_ir_reading_to_distance(RIGHT_DIST_IR_TYPE, right_analog);
		//		int center_analog = take_average(CENTER_DIST_IR_PORT, 1);
		//		center_distance = convert_ir_reading_to_distance(CENTER_DIST_IR_TYPE, center_analog);
		//		char buf[96];
		//		snprintf(buf, sizeof(buf), "Btm IR: %f, %d\n Top IR: %f, %d\n, Center IR: %f, %d\n",
		//		btm_distance, left_analog, top_distance, right_analog, center_distance, center_analog);
		//#ifdef WIFI_DEBUGGING
		//		send_debug_msg(buf, sizeof(buf));
		//#endif
		//get_heading();
		//motor[ROLLER_MOT_PORT] = 127;
//		int left_analog = take_average(BTM_DIST_IR_PORT, 1);
//		btm_distance = convert_ir_reading_to_distance(LEFT_DIST_IR_TYPE, left_analog);
//		bool left_curr_in_range =
//		check_within_range(btm_distance, 0, 400);
//		int right_analog = take_average(TOP_DIST_IR_PORT, 1);
//		top_distance = convert_ir_reading_to_distance(RIGHT_DIST_IR_TYPE, right_analog);
//		bool right_curr_in_range =
//		check_within_range(top_distance, 0, 400);
//		int center_analog = take_average(CENTER_DIST_IR_PORT, 1);
//		center_distance = convert_ir_reading_to_distance(CENTER_DIST_IR_TYPE, center_analog);
//		bool center_curr_in_range =
//		check_within_range(btm_distance, 0, 400);

//#ifdef WIFI_DEBUGGING
//		char buf1[32];
//		snprintf(buf1, sizeof(buf1), "Value: %.2f, %.2f, %.2f\n", left_analog, right_analog, center_analog);
//		send_debug_msg(buf1, sizeof(buf1));
//#endif
		//keep_door_closed();
		//int door_analog = take_average(DOOR_DIST_IR_PORT, 1);
		//float door_distance = convert_ir_reading_to_distance(DOOR_DIST_IR_TYPE, door_analog);
		//bool center_curr_in_range =
		//check_within_range(btm_distance, 0, 400);

		//#ifdef WIFI_DEBUGGING
		//		char buf1[32];
		//		snprintf(buf1, sizeof(buf1), "Value: %d, %.2f\n", door_analog, door_distance);
		//		send_debug_msg(buf1, sizeof(buf1));
		//#endif
#ifdef WIFI_DEBUGGING
		char buf1[64];
		snprintf(buf1, sizeof(buf1), "Frt Lft: %d\n Frt Rgt: %d\n Bck Lft: %d\n Bck Rgt: %d\n", SensorValue(FRT_LFT_REFL_IR_PORT),
		SensorValue(FRT_RGT_REFL_IR_PORT), SensorValue(BCK_LFT_REFL_IR_PORT), SensorValue(BCK_RGT_REFL_IR_PORT));
		send_debug_msg(buf1, sizeof(buf1));
#endif
		delay(500);
	}
#else
	while (true)
	{
		if (SensorValue(START_SWITCH_PORT) == 0)
		{
			char buf[24];
			snprintf(buf, sizeof(buf), "Beginning Task\n");
			send_debug_msg(buf, sizeof(buf));

			//Initalise values and start tasks clear timer must always be before start run machine task
			while (machine_heading == ERROR)
			{
				machine_heading = get_heading();
				delay(200);
			}
			goto_movetocenter();
			startTask(runMachine);
			break;
		}
	}
	while (1)
	{
	}
#endif
}
