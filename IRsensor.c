#pragma config(Sensor, dgtl1,  leftEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightEncoder,  sensorQuadEncoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//EVERYTHING DISTANCE RELATED IN mm!
//Motor Definitions

#define LEFT_MOT_PORT port3
#define RIGHT_MOT_PORT port5
#define DOOR_MOT_PORT port4
#define ROLLER_MOT_PORT port2
#define DOOR_MOT_SPEED 50
#define SPEED_OFFSET 0.0
#define SLOW_SPEED 20.0
#define OP_SPEED 127.0

//Limit Switch Definitions
#define DOOR_LSWITCH_PORT dgtl11
#define BALL_LSWITCH_PORT dgtl12

//Distance IR Sensor Definitions
#define RIGHT_DIST_IR_TYPE ORANGE_GREEN
#define RIGHT_DIST_IR_PORT in1
#define LEFT_DIST_IR_TYPE ORANGE_YELLOW
#define LEFT_DIST_IR_PORT in2
#define DOOR_DIST_IR_TYPE ORANGE_BLUE
#define DOOR_DIST_IR_PORT in3
#define DOOR_DIST_IR_THRESHOLD 130.0 //in mm
#define DIST_IR_MAX_DIFF 68.0 //in mm
#define DIST_IR_MIN_DIFF 150.0 //in mm
#define LEFT_DIST_IR_OFFSET 70.0//

//Reflective Sensor Definitions
#define FRT_LFT_REFL_IR_PORT in4
#define FRT_RGT_REFL_IR_PORT in5
#define FRT_LFT_REFL_IR_THRESHOLD 1500
#define FRT_RGT_REFL_IR_THRESHOLD 1500
#define BCK_LFT_REFL_IR_PORT in4
#define BCK_RGT_REFL_IR_PORT in5
#define BCK_LFT_REFL_IR_THRESHOLD 1500
#define BCK_RGT_REFL_IR_THRESHOLD 1500

//Compass Definitions
#define NORTH_PORT dgtl3
#define EAST_PORT dgtl4
#define WEST_PORT dgtl5
#define SOUTH_PORT dgtl6

//Utils
#define WIFI_DEBUGGING 0
#define UART_PORT uartOne
#define BALL_DIAMETER 63.0
#define ANGLE_SLICE 0.16


float lowest_reading = 9999;


enum ir_sensor{ORANGE_PINK, ORANGE_GREEN, ORANGE_YELLOW, ORANGE_BLUE, NUMBER_OF_IR_SENSORS};
enum direction{STOP, REVERSE, STRAIGHT, CLOCKWISE, CCLOCKWISE};
enum bearing{NORTH, NORTHEAST, EAST, SOUTHEAST, SOUTH, SOUTHWEST, WEST, NORTHWEST, ERROR};
enum mode{MOVE_TO_CENTER, SEARCH_FOR_BALL, MOVE_TO_BALL, RETURN_BALL};
enum return_ball_seq{ALIGN_BEARING, RETURN_TO_BASE, DEPOSIT_BALL};

/*Thresholds are at 10-60cm as the anything above 60cm for the 10-80cm sensors is just too bad
For 4-30cm, threshold taken at 30cm
*/
int ir_sensor_max_value[(int) NUMBER_OF_IR_SENSORS] = {1853, 1828, 1884, 1978};
int ir_sensor_min_value[(int) NUMBER_OF_IR_SENSORS] = {508, 472, 476, 307};

/*
MA4012
Group Project
YuPin edit 22/2/2022
*/
mode machine_mode = MOVE_TO_CENTER;
mode machine_return_ball_seq = ALIGN_BEARING;
const int slow_speed = 20;


void send_debug_msg(char* msg, int size)
{
#ifdef WIFI_DEBUGGING
	for (int i = 0; i < size; i ++)
	{
		sendChar(UART_PORT, msg[i]);
	}
#endif
}

bool check_within_range(float value, float min, float max)
{
	return value <= min || value >= max ?  false : true;
}

float convert_ir_reading_to_distance(ir_sensor sensor, int analog)
{
	analog /= 4;
	switch(sensor)
	{
	case ORANGE_BLUE:
		return 2316.4 * pow(analog, -0.998) * 10;
		break;
	case ORANGE_GREEN:
		return 49865 * pow(analog, -1.416) * 10;
		break;
	case ORANGE_PINK:
		return 166922 * pow(analog, -1.604) * 10;
		break;
	case ORANGE_YELLOW:
		return 44924 * pow(analog, -1.394) * 10;
		break;
	default:
		return -1;
	}
}

void movement(direction directionMode, int speed = 0){
	int speed1 = abs(speed * 1.02);
	switch (directionMode)
	{
	case STOP:
		motor[LEFT_MOT_PORT] = 0;
		motor[RIGHT_MOT_PORT] = 0;
		break;
	case REVERSE:
		motor[LEFT_MOT_PORT] = -speed;
		motor[RIGHT_MOT_PORT] = speed1;
		break;
	case STRAIGHT:
		motor[LEFT_MOT_PORT] = speed;
		motor[RIGHT_MOT_PORT] = -speed1;
		break;
	case CLOCKWISE:
		motor[LEFT_MOT_PORT] = speed;
		motor[RIGHT_MOT_PORT] = speed1;
		break;
	case CCLOCKWISE:
		motor[LEFT_MOT_PORT] = -speed;
		motor[RIGHT_MOT_PORT] = -speed1;
		break;
	default:
		motor[LEFT_MOT_PORT] = 0;
		motor[RIGHT_MOT_PORT] = 0;
		break;
	}
}


//void detect_boundary(int left_f, int right_f){
//	if(left_f==0 && right_f==0){	//detect both front sensors -> turn right full round
//		movement_t(-1,slow_speed,1000);
//		movement_t(3,slow_speed,4000);
//		movement(0,0);
//	}
//	else if (left_f==0){					//detect left sensor -> turn left
//		movement_t(3,slow_speed,2000);
//		movement(0,0);
//	}
//	else if (right_f==0){					//detect right sensor -> turn right
//		movement_t(2,slow_speed,2000);
//		movement(0,0);
//	}
//}

bool detect_ball_deposit()
{
	if (SensorValue(DOOR_LSWITCH_PORT) == 1)
	{
		return (SensorValue(DOOR_DIST_IR_PORT) > DOOR_DIST_IR_THRESHOLD);
	}
	return false;
}

int take_average(tSensors sensor_port, int readings)
{
	float average = 0;
	for (int i =0; i < readings; i++)
	{
		average +=  SensorValue(sensor_port);
	}
	return average /  readings;
}

float clamp(float d, float min, float max) {
	const float t = d < min ? min : d;
	return t > max ? max : t;
}


bool check_ball_threshold(int count, int sensor_distance){
	int count_lower_limit, count_higher_limit;
	if (sensor_distance >500) {
		count_lower_limit = 2;
		count_higher_limit = 2;
	}
	else if (sensor_distance<=500 && sensor_distance>400) {
		count_lower_limit = 2;
		count_higher_limit = 3;
	}
	else if (sensor_distance<=400 ){
		count_lower_limit = 3;
		count_higher_limit = 6;
	}

	if (count>= count_lower_limit && count <= count_higher_limit){
		return true;
	}
	else{
		return false;
	}
}

bool detect_ballv3()
{
	const int array_size = 10;
	static float dist_array[array_size] = {1800.0, 1800.0, 1800.0, 1800.0,
		1800.0, 1800.0, 1800.0, 1800.0, 1800.0, 1800.0};

	int lowest_reading_index = 0;
	int count = 0;
	int left_analog = take_average(LEFT_DIST_IR_PORT, 1);
	bool curr_in_range =
	check_within_range(left_analog, ir_sensor_min_value[LEFT_DIST_IR_TYPE], ir_sensor_max_value[LEFT_DIST_IR_TYPE]);
	float ir_distance = convert_ir_reading_to_distance(LEFT_DIST_IR_TYPE, left_analog);
	lowest_reading = ir_distance;
	for (int i = 0; i < array_size - 1; i++)
	{
		dist_array[i] = dist_array[i+1];
	}
	dist_array[array_size - 1] = ir_distance;
#ifdef WIFI_DEBUGGING
	char buf1[8] = "Start: ";
	char buf2[8] = "\n";
	send_debug_msg(buf1, sizeof(buf1));
	for (int i = 0; i < array_size; i++)
	{
		char buf[16];
		snprintf(buf, sizeof(buf), "%d, ", (int)dist_array[i]);
		send_debug_msg(buf, sizeof(buf));
	}
	send_debug_msg(buf2, sizeof(buf2));
#endif
	for (int i = 0; i < array_size; i++)
	{
		if (dist_array[i] < lowest_reading)
		{
			lowest_reading = dist_array[i];
			lowest_reading_index = i;
		}
	}

	if (lowest_reading == 0  ||
		check_within_range(lowest_reading, ir_sensor_min_value[LEFT_DIST_IR_TYPE],
	ir_sensor_max_value[LEFT_DIST_IR_TYPE]))
	{
		return false;
	}

	float ratio_thresh = -0.005 * lowest_reading + 4.3;

	//right search
	bool nir_found;
	bool nir_1=false;
	bool nir_2=false;
	for (int i = lowest_reading_index; i < array_size; i++)
	{
		float ratio;
		ratio = dist_array[i]/lowest_reading;
		if (ratio <= ratio_thresh)
		{
			count = count + 1;
		}
		else
		{
			nir_1 = true;
			goto end;

		}
	}
end:
	for (int i = lowest_reading_index; i >= 0; i--)
	{
		float ratio;
		ratio = dist_array[i]/lowest_reading;
		if (ratio <= ratio_thresh)
		{
			count = count + 1;
		}
		else
		{
			nir_2 = true;
			goto end2;

		}
	}
end2:
	nir_found = nir_1 && nir_2;
	int count_thresh = -0.0079 * lowest_reading + 5.6499;
	count = count-1;
#ifdef WIFI_DEBUGGING
	char buf3[8] = "Value: ";
	char buf4[8] = "\n";
	send_debug_msg(buf3, sizeof(buf1));
	char buf[64];
	snprintf(buf, sizeof(buf), "%f, %d, %d, %f ", ratio_thresh, count_thresh, count, lowest_reading);
	send_debug_msg(buf, sizeof(buf));
	send_debug_msg(buf4, sizeof(buf2));
#endif

	if (count >= (count_thresh - 1) && count <= count_thresh && count != 0 && nir_found)
	{
#ifdef WIFI_DEBUGGING
		char buf[64];
		snprintf(buf, sizeof(buf), "DETECTED!!!!!!!!!!!");
		send_debug_msg(buf, sizeof(buf));
#endif
		for (int i = 0; i < array_size; i++)
		{
			dist_array[i] = 1800.0;
		}
		return true;

	}
	return false;
}


bool detect_ball_fieldv2()
{

	static bool prev_in_range = false;
	static int count = 0;
	static float prev_reading = 0;
	static float lowest_reading = 9000.0;
	bool result = false;
	int left_analog = take_average(LEFT_DIST_IR_PORT, 1);
	bool curr_in_range =
	check_within_range(left_analog, ir_sensor_min_value[LEFT_DIST_IR_TYPE], ir_sensor_max_value[LEFT_DIST_IR_TYPE]);
	float ir_distance = convert_ir_reading_to_distance(LEFT_DIST_IR_TYPE, left_analog);
#ifdef WIFI_DEBUGGING
	char buf[96];
	snprintf(buf, sizeof(buf), "ir_distance: %f, %f, %d, %f\n", ir_distance, prev_reading, count, lowest_reading);
	send_debug_msg(buf, sizeof(buf));
	writeDebugStreamLine(buf);
#endif
	if(curr_in_range && prev_in_range)
	{
		if (abs(ir_distance - prev_reading) >= DIST_IR_MIN_DIFF)
		{
			result = check_ball_threshold(count,lowest_reading);
			count = 0;
#ifdef WIFI_DEBUGGING
			char buf[64];
			snprintf(buf, sizeof(buf), "Both in range! Result: %d\n", result);
			send_debug_msg(buf, sizeof(buf));
			writeDebugStreamLine(buf);
#endif
		}
		else
		{
			count = count + 1;
			if (ir_distance < lowest_reading)
			{
				lowest_reading = ir_distance;
			}
#ifdef WIFI_DEBUGGING
			char buf[64];
			snprintf(buf, sizeof(buf), "Adding Count! Count: %d\n", count);
			send_debug_msg(buf, sizeof(buf));
			writeDebugStreamLine(buf);
#endif
			result = false;
		}
	}
	else if (!curr_in_range && prev_in_range)
	{
		result = check_ball_threshold(count, lowest_reading);
		count = 0;
#ifdef WIFI_DEBUGGING
		char buf[64];
		snprintf(buf, sizeof(buf), "Exited Range! Result: %d\n", result);
		send_debug_msg(buf, sizeof(buf));
		writeDebugStreamLine(buf);
#endif
	}
	else if (curr_in_range && !prev_in_range)
	{
		count = 1;
		lowest_reading = ir_distance;
		result = false;
#ifdef WIFI_DEBUGGING
		char buf[64];
		snprintf(buf, sizeof(buf), "Detected Edge!");
		send_debug_msg(buf, sizeof(buf));
		writeDebugStreamLine(buf);
#endif
	}
	else if (!curr_in_range && !prev_in_range)
	{
#ifdef WIFI_DEBUGGING
		char buf[64];
		snprintf(buf, sizeof(buf), "Nothing\n", count);
		send_debug_msg(buf, sizeof(buf));
		writeDebugStreamLine(buf);
#endif
		count = 0;
		lowest_reading = 9000.0;
		result = false;
	}
	prev_in_range = curr_in_range;
	prev_reading = ir_distance;
	return result;
}

int correction_time(float reading){

	return reading/3 + 200;
}

bool detect_ball_collector(){
	return (SensorValue(BALL_LSWITCH_PORT) == 1);
}

enum bearing get_heading()
{
	byte heading = 0x00;
	heading & SensorValue(NORTH_PORT) & (SensorValue(EAST_PORT) << 1) & (SensorValue(SOUTH_PORT) << 2) & (SensorValue(WEST_PORT) << 3);
	switch (heading)
{	case 1:
		return NORTH;
		break;
	case  3:
		return NORTHEAST;
		break;
	case 2:
		return EAST;
		break;
	case 6:
		return SOUTHEAST;
		break;
	case 4:
		return SOUTH;
		break;
	case 12:
		return SOUTHWEST;
		break;
	case 8:
		return WEST;
		break;
	case 9:
		return NORTHWEST;
		break;
	default:
		return ERROR;
	}
}

void move_to_ball(/*distance*/){
	//
}

void start_process(){
	//movement to middle of field
}


void align_orientation(){
	//compass value
}

void move_to_collection(){
	movement(REVERSE, slow_speed);
	//release ball
	start_process();
}

void keep_door_closed()
{
	motor[DOOR_MOT_PORT] = DOOR_MOT_SPEED * (SensorValue[DOOR_LSWITCH_PORT] == 0);
}

void run_machine()
{
	static unsigned long timer = 0;
	switch (machine_mode)
	{
	case MOVE_TO_CENTER:
		motor[ROLLER_MOT_PORT] = 127;
		movement(STRAIGHT, 100);
		if (time1[T1] > 4000)
		{
			machine_mode = SEARCH_FOR_BALL;
			clearTimer(T1);
		}
		break;
	case SEARCH_FOR_BALL:
		motor[ROLLER_MOT_PORT] = 127;
		if (detect_ball_collector)
		{
			machine_mode = RETURN_BALL;
			break;
		}
		if (direction1 == STRAIGHT)
		{
			movement(direction1, search_ball_speed);
		}
		movement(direction1, search_ball_speed);
		if (detect_ballv3())
		{
			machine_mode = MOVE_TO_BALL;
			clearTimer(T1);
			break;
		}
		if (time1[T1]>4000) //can replace this with compass usage to track if robot rotated almost 360degrees
		{
			direction1 = STRAIGHT;
			search_ball_speed = 100;
			clearTimer(T1);
			break;
		}
		if (time1[T1]>2000 && direction1 == STRAIGHT)
		{
			direction1 = CLOCKWISE;
			search_ball_speed = 24;
			clearTimer(T1);
		}
		break;
	case MOVE_TO_BALL:
		motor[ROLLER_MOT_PORT] = 127;
		movement(CCLOCKWISE, 24);
		delay(correction_time(lowest_reading));
		movement(STRAIGHT, 100);
		//continue on, not completed
		//
		//
		break;
	case RETURN_BALL:
		motor[ROLLER_MOT_PORT] = -40;
		switch (machine_return_ball_seq)
		{
		case ALIGN_BEARING:
			break;
		case RETURN_TO_BASE:
			movement(REVERSE, OP_SPEED);
			if (detect_ball_deposit())
			{
				machine_return_ball_seq = DEPOSIT_BALL;
			}
			break;
		case DEPOSIT_BALL:
			motor[DOOR_MOT_PORT] = DOOR_MOT_SPEED;
			delay(300);
			machine_mode = MOVE_TO_CENTER;
			break;
		}
		break;
	default:
		break;
	}
}




task runMachine()
{
	direction direction1 = CLOCKWISE;
	int search_ball_speed = 24;
	while(1)
	{
		run_machine();
		writeDebugStreamLine("runmachine");
		wait1Msec(20);
	}
}

task edgeDetection()
{
	const int reverse_speed = 100;
	const int rotate_speed = 100;
	while(1)
	{
		bool front_left_detected = SensorValue(FRT_LFT_REFL_IR_PORT) <= FRT_LFT_REFL_IR_THRESHOLD;
		bool front_right_detected = SensorValue(FRT_RGT_REFL_IR_PORT) <= FRT_RGT_REFL_IR_THRESHOLD;
		bool back_left_detected = SensorValue(BCK_LFT_REFL_IR_PORT) <= BCK_LFT_REFL_IR_THRESHOLD;
		bool back_right_detected = SensorValue(BCK_RGT_REFL_IR_PORT) <= BCK_RGT_REFL_IR_THRESHOLD;
		if (front_left_detected)
		{
			movement(REVERSE,reverse_speed);
			delay(300);
			movement(CLOCKWISE,rotate_speed);
			delay(300);
		}
		else if (front_right_detected)
		{
			movement(REVERSE,reverse_speed);
			delay(300);
			movement(CCLOCKWISE,rotate_speed);
			delay(300);
		}
		else if (back_left_detected)
		{
			movement(STRAIGHT,reverse_speed);
			delay(300);
			movement(CLOCKWISE,rotate_speed);
			delay(300);
		}
		else if (back_right_detected)
		{
			movement(STRAIGHT,reverse_speed);
			delay(300);
			movement(CCLOCKWISE,rotate_speed);
			delay(300);
		}
		wait1Msec(200);
	}
}

//////////////////////////////////////////////////////////
task main()
{
#ifdef WIFI_DEBUGGING
	setBaudRate(UART_PORT, baudRate115200);
	send_debug_msg("Vex Started\n", 13);
	writeDebugStreamLine("%d", nImmediateBatteryLevel);

	while(true)
	{
		if (getChar(UART_PORT) == '1')
		{
			send_debug_msg("Break loop\n", 13);
			startTask(runMachine, kDefaultTaskPriority + 1);
			startTask(edgeDetection);
			clearTimer(T1);
			break;
		}
	}
#endif
	//while (true)
	//{

	//	//detect_ball_field();
	//	movement(direction1, 24);

	//	lowest_reading = 9999;
	//	if (detect_ballv3())
	//	{
	//		movement(CCLOCKWISE, 24);
	//		delay(correction_time(lowest_reading));
	//		movement(STRAIGHT, 100);
	//		motor[port2] = 127;
	//		delay(1000);
	//		movement(STOP);
	//		direction1 = STOP;
	//	}

	//	if (getChar(UART_PORT) == '1')
	//	{
	//		direction1 = CLOCKWISE;
	//	}
	//	else if (getChar(UART_PORT) == '0'){
	//		direction1 = STOP;
	//	}
	//	delay(50);
	//}

	//Don't remove
	while (1)
	{
	}
}
