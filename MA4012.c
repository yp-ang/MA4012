#pragma config(Sensor, port1,  outerSensorTop, sensorNone)
#pragma config(Sensor, port2,  outerSensorBottom, sensorNone)
#pragma config(Sensor, port3,  rampSensor,     sensorNone)
#pragma config(Sensor, port4,  lSwitchLeftFront, sensorDigitalIn)
#pragma config(Sensor, port5,  lSwitchLeftBack, sensorDigitalIn)
#pragma config(Sensor, port6,  lSwitchRightFront, sensorDigitalIn)
#pragma config(Sensor, port7,  lSwitchRightBack, sensorDigitalIn)
#pragma config(Sensor, port8,  lSwitchBackLeft, sensorDigitalIn)
#pragma config(Sensor, port9,  lSwitchBackRight, sensorDigitalIn)
#pragma config(Sensor, dgtl1,  compassNorth, sensorDigitalIn)
#pragma config(Sensor, dgtl2,  compassEast, sensorDigitalIn)
#pragma config(Sensor, dgtl3,  compassSouth, sensorDigitalIn)
#pragma config(Sensor, dgtl4,  compassWest, sensorDigitalIn)
#pragma config(Motor,  motor1, motorLeftWheel, tmotorNone, openLoop)
#pragma config(Motor,  motor2, motorRightWheel, tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

#define WHEEL_DIAMETER_IN_CM
#define WHEEL_DISTANCE_IN_CM
#define LONG_IR_MIN_ANALOG 400
#define LONG_IR_MAX_ANALOG 2700
#define TOP_BOTTOM_IR_DIFFERENCE 8.0

enum bearing{NORTH, NORTHEAST, EAST, SOUTHEAST, SOUTH, SOUTHWEST, WEST, NORTHWEST, ERROR};
enum mode{INITIALISING, SEARCHING_BALL, MOVING_TO_BALL, CAPTURING_BALL, RETURNING_BALL, RETURNING_TO_BOUNDS, EVASIVE_MANEUVER};

float xCoordinate;
float yCoordinate;
float theta;
enum mode currentMode;

float analogToDistanceLongIR(int analog);
bool checkWithinRange(float value, float min, float max);
bool checkIfBallCollected();
bool moveToCoordinate(float x, float y, float theta);
bool detectedBallOrRobot();
enum bearing getHeading();
bool searchForBall();
bool returnToCollectionPoint();
void runRobot();

/*
Converts analog reading from IR sensor into distance in cm.
@param analog: analog reading from the pin
@return distance: distance in cm from ir to object
*/

float analogToDistanceLongIR(int analog)
{
	float distance;
	//Covert the analog to distance;
	return distance;
}

/*
Checks if input value is within a certain range
@param value: value to check
@param min: min value of range
@param max: max value of range
@return bool: true if within range, false if not
*/

bool checkWithinRange(float value, float min, float max)
{
	return value <= min || value >= max ?  false : true;
}

/*
Check if ball is collected
@return bool: true if ball detected in holding area, false if not
*/

bool checkIfBallCollected()
{
}

/*
Moves car to a certain coordinate
@return bool: true if ball reached coordinate, false if not
*/

bool moveToCoordinate(float x, float y, float theta)
{
}

bool detectedBallOrRobot()
{
	float outerSensorBottomDistance = analogToDistanceLongIR(SensorValue(outerSensorBottom));
	float outerSensorTopDistance = analogToDistanceLongIR(SensorValue(outerSensorTop));
	if (checkWithinRange(outerSensorBottom, LONG_IR_MIN_ANALOG, LONG_IR_MAX_ANALOG))
	{	if (checkWithinRange(outerSensorTop, LONG_IR_MIN_ANALOG, LONG_IR_MAX_ANALOG))
		{
			if (outerSensorTopDistance - outerSensorBottomDistance > 8.0)
			{
				//ball detected
			}
			//robot detected
			return true;
		}

	}
	// nothing detected
	return false;
}

/*
Determines heading based on output of 4 digital pins
@returns enum value of heading
*/

enum bearing getHeading()
{
	byte heading = 0x00;
	heading & SensorValue(compassNorth) & (SensorValue(compassEast) << 1) & (SensorValue(compassSouth) << 2) & (SensorValue(compassWest) << 3);
	switch (heading)
{	case 1:
		return NORTH;
		break;
	case  3:
		return NORTHEAST;
		break;
	case 2:
		return EAST;
		break;
	case 6:
		return SOUTHEAST;
		break;
	case 4:
		return SOUTH;
		break;
	case 12:
		return SOUTHWEST;
		break;
	case 8:
		return WEST;
		break;
	case 9:
		return NORTHWEST;
		break;
	default:
		return ERROR;
	}
}

/*
Search for balls
@return bool: true if ball detected, false if not
*/
bool searchForBall()
{
}

/*
Moves the machine back to the collection point
@return bool: true if returned to collection point, false if not
*/

bool returnToCollectionPoint()
{
}

/*
Runs the robot based on the current enum its at.
*/

void runRobot()
{
	switch(currentMode)
	{
	case  INITIALISING:
		break;
	case  SEARCHING_BALL:
		break;
	case  MOVING_TO_BALL:
		break;
	case  CAPTURING_BALL:
		break;
	case  RETURNING_BALL:
		break;
	case  RETURNING_TO_BOUNDS:
		break;
	case  EVASIVE_MANEUVER:
		break;
	default:
		break
	}

}

task main()
{

}
