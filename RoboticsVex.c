#pragma config(Sensor, dgtl11, ,               sensorDigitalIn)
#pragma config(Sensor, dgtl12, ,               sensorDigitalIn)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//EVERYTHING DISTANCE RELATED IN mm!
//Motor Definitions

#define LEFT_MOT_PORT port3
#define RIGHT_MOT_PORT port5
#define DOOR_MOT_PORT port4
#define ROLLER_MOT_PORT port2
#define DOOR_MOT_SPEED 50
#define SPEED_OFFSET 0.0
#define SLOW_SPEED 20.0
#define OP_SPEED 127.0

//Limit Switch Definitions
#define DOOR_LSWITCH_PORT dgtl11
#define BALL_LSWITCH_PORT dgtl12

//Distance IR Sensor Definitions
#define RIGHT_DIST_IR_TYPE ORANGE_YELLOW
#define RIGHT_DIST_IR_PORT in1
#define LEFT_DIST_IR_TYPE ORANGE_GREEN
#define LEFT_DIST_IR_PORT in2
#define DOOR_DIST_IR_TYPE ORANGE_BLUE
#define DOOR_DIST_IR_PORT in3
#define DOOR_DIST_IR_THRESHOLD 130.0 //in mm
#define DIST_IR_MAX_DIFF 68.0 //in mm
#define DIST_IR_MIN_DIFF 30.0 //in mm
#define LEFT_DIST_IR_OFFSET 70.0//

//Reflective Sensor Definitions
#define FRT_LFT_REFL_IR_PORT in4
#define FRT_RGT_REFL_IR_PORT in5
#define FRT_LFT_REFL_IR_THRESHOLD 1100
#define FRT_RGT_REFL_IR_THRESHOLD 1100
#define BCK_LFT_REFL_IR_PORT in4
#define BCK_RGT_REFL_IR_PORT in5
#define BCK_LFT_REFL_IR_THRESHOLD 1100
#define BCK_RGT_REFL_IR_THRESHOLD 1100

//Compass Definitions
#define NORTH_PORT dgtl3
#define EAST_PORT dgtl4
#define WEST_PORT dgtl5
#define SOUTH_PORT dgtl6

//Utils
#define WIFI_DEBUGGING 0
#define UART_PORT uartOne
#define BALL_DIAMETER 63.0
#define ANGLE_SLICE 0.0418


enum ir_sensor{ORANGE_PINK, ORANGE_GREEN, ORANGE_YELLOW, ORANGE_BLUE, NUMBER_OF_IR_SENSORS};
enum direction{STOP, REVERSE, STRAIGHT, CLOCKWISE, CCLOCKWISE};
enum bearing{NORTH, NORTHEAST, EAST, SOUTHEAST, SOUTH, SOUTHWEST, WEST, NORTHWEST, ERROR};
enum mode{MOVE_TO_CENTER, SEARCH_FOR_BALL, MOVE_TO_BALL, RETURN_BALL};
enum return_ball_seq{ALIGN_BEARING, RETURN_TO_BASE, DEPOSIT_BALL};

/*Thresholds are at 10-60cm as the anything above 60cm for the 10-80cm sensors is just too bad
For 4-30cm, threshold taken at 30cm
*/
int ir_sensor_max_value[(int) NUMBER_OF_IR_SENSORS] = {1853, 1828, 1884, 1978};
int ir_sensor_min_value[(int) NUMBER_OF_IR_SENSORS] = {512, 430, 429, 307};

/*
MA4012
Group Project
YuPin edit 22/2/2022

*/
mode machine_mode = MOVE_TO_CENTER;
mode machine_return_ball_seq = ALIGN_BEARING;
const int slow_speed = 20;

void send_debug_msg(char* msg, int size)
{
#ifdef WIFI_DEBUGGING
	for (int i = 0; i < size; i ++)
	{
		sendChar(UART_PORT, msg[i]);
	}
#endif
}

bool check_within_range(float value, float min, float max)
{
	return value <= min || value >= max ?  false : true;
}

float convert_ir_reading_to_distance(ir_sensor sensor, int analog)
{
	analog /= 4;
	switch(sensor)
	{
	case ORANGE_BLUE:
		return 2316.4 * pow(analog, -0.998) * 10;
		break;
	case ORANGE_GREEN:
		return 49865 * pow(analog, -1.416) * 10;
		break;
	case ORANGE_PINK:
		return 166922 * pow(analog, -1.604) * 10;
		break;
	case ORANGE_YELLOW:
		return 44924 * pow(analog, -1.394) * 10;
		break;
	default:
		return -1;
	}
}

void movement(direction directionMode, int speed = 0){
	switch (directionMode)
	{
	case STOP:
		motor[LEFT_MOT_PORT] = 0;
		motor[RIGHT_MOT_PORT] = 0;
		break;
	case STRAIGHT:
		motor[LEFT_MOT_PORT] = -speed;
		motor[RIGHT_MOT_PORT] = speed;
		break;
	case REVERSE:
		motor[LEFT_MOT_PORT] = speed;
		motor[RIGHT_MOT_PORT] = -speed;
		break;
	case CLOCKWISE:
		motor[LEFT_MOT_PORT] = speed;
		motor[RIGHT_MOT_PORT] = speed;
		break;
	case CCLOCKWISE:
		motor[LEFT_MOT_PORT] = -speed;
		motor[RIGHT_MOT_PORT] = -speed;
		break;
	default:
		motor[LEFT_MOT_PORT] = 0;
		motor[RIGHT_MOT_PORT] = 0;
		break;
	}
}


//void detect_boundary(int left_f, int right_f){
//	if(left_f==0 && right_f==0){	//detect both front sensors -> turn right full round
//		movement_t(-1,slow_speed,1000);
//		movement_t(3,slow_speed,4000);
//		movement(0,0);
//	}
//	else if (left_f==0){					//detect left sensor -> turn left
//		movement_t(3,slow_speed,2000);
//		movement(0,0);
//	}
//	else if (right_f==0){					//detect right sensor -> turn right
//		movement_t(2,slow_speed,2000);
//		movement(0,0);
//	}
//}

bool detect_ball_deposit()
{
	if (SensorValue(DOOR_LSWITCH_PORT) == 1)
	{
		return (SensorValue(DOOR_DIST_IR_PORT) > DOOR_DIST_IR_THRESHOLD);
	}
	return false;
}

int take_average(tSensors sensor_port, int readings)
{
	float average = 0;
	for (int i =0; i < readings; i++)
	{
		average +=  SensorValue(sensor_port);
	}
	return average /  readings;
}

float clamp(float d, float min, float max) {
	const float t = d < min ? min : d;
	return t > max ? max : t;
}

bool detect_ball_fieldv2()
{
	static bool in_range = false;
	static int count = 0;
	static int value = 0;
	static float prev_reading = 0;
	int left_analog = take_average(LEFT_DIST_IR_PORT, 1);
	bool left_within_range =
	check_within_range(left_analog, ir_sensor_min_value[LEFT_DIST_IR_TYPE], ir_sensor_max_value[LEFT_DIST_IR_TYPE]);
	float left_distance = convert_ir_reading_to_distance(LEFT_DIST_IR_TYPE, left_analog);
#ifdef WIFI_DEBUGGING
	char buf[64];
	snprintf(buf, sizeof(buf), "left_distance: %f\n", left_distance);
	send_debug_msg(buf, sizeof(buf));
	writeDebugStreamLine(buf);
#endif
	if (!in_range && left_within_range)
	{
		value = atan(BALL_DIAMETER/2/(left_distance + LEFT_DIST_IR_OFFSET))/ANGLE_SLICE * 2;
		prev_reading = left_distance;
		count = 1;
		in_range = true;
#ifdef WIFI_DEBUGGING
		char buf[64];
		snprintf(buf, sizeof(buf), "Detected Edge!\n Value: %d\n", value);
		send_debug_msg(buf, sizeof(buf));
			writeDebugStreamLine(buf);
#endif
	}
	else if (in_range && !left_within_range)
	{
		if (count == value)
		{
#ifdef WIFI_DEBUGGING
			char buf[64];
			snprintf(buf, sizeof(buf), "Found Edge To Void Suc!\n Value: %d, Count: %d\n", value, count);
			send_debug_msg(buf, sizeof(buf));
			count = 0;
				writeDebugStreamLine(buf);
#endif
			//detected a ball
			return true;
		}
#ifdef WIFI_DEBUGGING
		char buf[64];
		snprintf(buf, sizeof(buf), "Found Edge To Void Fai!\n Value: %d, Count: %d\n", value, count);
		send_debug_msg(buf, sizeof(buf));
		count = 0;
			writeDebugStreamLine(buf);
#endif
		return false;
	}
	else if (in_range && left_within_range && (abs(prev_reading - left_distance) <= DIST_IR_MIN_DIFF))
	{
		count ++;
#ifdef WIFI_DEBUGGING
		char buf[64];
		snprintf(buf, sizeof(buf), "Adding Count!\n Count: %d\n", count);
		send_debug_msg(buf, sizeof(buf));
			writeDebugStreamLine(buf);
#endif
		return false;
	}
	else
	{
		if (count == value && value != 0)
		{
#ifdef WIFI_DEBUGGING
			char buf[64];
			snprintf(buf, sizeof(buf), "Found Edge To Wall Suc!\n Value: %d, Count: %d\n", value, count);
			send_debug_msg(buf, sizeof(buf));
			count = 0;
				writeDebugStreamLine(buf);
#endif
			//detected a ball
			return true;
		}
		else
		{
			value = atan(BALL_DIAMETER/2/(left_distance + LEFT_DIST_IR_OFFSET))/ANGLE_SLICE;
			prev_reading = left_distance;
			count = 1;
#ifdef WIFI_DEBUGGING
			char buf[64];
			snprintf(buf, sizeof(buf), "Found Edge To Wall Fai!\n Value: %d, Count: %d\n", value, count);
			send_debug_msg(buf, sizeof(buf));
			count = 0;
				writeDebugStreamLine(buf);
#endif
			return false;
		}
	}
}

bool detect_ball_field(){
	int left_analog = take_average(LEFT_DIST_IR_PORT, 4);
	int right_analog = take_average(RIGHT_DIST_IR_PORT, 4);
	float left_distance = convert_ir_reading_to_distance(LEFT_DIST_IR_TYPE, left_analog);
	float right_distance = convert_ir_reading_to_distance(RIGHT_DIST_IR_TYPE, right_analog);
	bool right_within_range =
	check_within_range(right_analog, ir_sensor_min_value[RIGHT_DIST_IR_TYPE], ir_sensor_max_value[RIGHT_DIST_IR_TYPE]);
	bool left_within_range =
	check_within_range(left_analog, ir_sensor_min_value[LEFT_DIST_IR_TYPE], ir_sensor_max_value[LEFT_DIST_IR_TYPE]);
#ifdef WIFI_DEBUGGING
	char buf[64];
	snprintf(buf, sizeof(buf), "left distance: %f, right distance: %f\n",
	left_distance, right_distance);
	send_debug_msg(buf, sizeof(buf));
#endif
	//If one sensors detected a distance while the other didn't, probably a ball
	if (!right_within_range != !left_within_range)
	{
#ifdef WIFI_DEBUGGING
		send_debug_msg("Only one sensor\n", 24);
#endif
		return true;
	}

	//Two distances are detected then we need to subtract the distance
	else if (right_within_range && left_within_range)
	{

		//If values are above a certain threshold, probably a ball, with robot behind
		if (abs(right_distance - left_distance) > DIST_IR_MIN_DIFF)
		{
#ifdef WIFI_DEBUGGING
			send_debug_msg("Dist Threshold\n", 24);
#endif
			return true;
		}
		else
		{
#ifdef WIFI_DEBUGGING
			send_debug_msg("Nothing\n", 24);
#endif
		}

		//else is robot
	}
	// Detect nothing so just return false
	return false;
}

bool detect_ball_collector(){
	return (SensorValue(BALL_LSWITCH_PORT) == 1);
}

enum bearing get_heading()
{
	byte heading = 0x00;
	heading & SensorValue(NORTH_PORT) & (SensorValue(EAST_PORT) << 1) & (SensorValue(SOUTH_PORT) << 2) & (SensorValue(WEST_PORT) << 3);
	switch (heading)
{	case 1:
		return NORTH;
		break;
	case  3:
		return NORTHEAST;
		break;
	case 2:
		return EAST;
		break;
	case 6:
		return SOUTHEAST;
		break;
	case 4:
		return SOUTH;
		break;
	case 12:
		return SOUTHWEST;
		break;
	case 8:
		return WEST;
		break;
	case 9:
		return NORTHWEST;
		break;
	default:
		return ERROR;
	}
}

void move_to_ball(/*distance*/){
	//
}

void start_process(){
	//movement to middle of field
}


void align_orientation(){
	//compass value
}

void move_to_collection(){
	movement(REVERSE, slow_speed);
	//release ball
	start_process();
}

void keep_door_closed()
{
	motor[DOOR_MOT_PORT] = DOOR_MOT_SPEED * (SensorValue[DOOR_LSWITCH_PORT] == 0);
}

void run_machine()
{
	switch (machine_mode)
	{
	case MOVE_TO_CENTER:
		break;
	case SEARCH_FOR_BALL:
		break;
	case MOVE_TO_BALL:
		break;
	case RETURN_BALL:
		switch (machine_return_ball_seq)
		{
		case ALIGN_BEARING:
			break;
		case RETURN_TO_BASE:
			movement(REVERSE, OP_SPEED);
			if (detect_ball_deposit())
			{
				machine_return_ball_seq = DEPOSIT_BALL;
			}
			break;
		case DEPOSIT_BALL:
			motor[DOOR_MOT_PORT] = DOOR_MOT_SPEED;
			delay(300);
			machine_mode = MOVE_TO_CENTER;
			break;
		}
		break;
	default:
		break;
	}
}

direction direction1 = STOP;
//////////////////////////////////////////////////////////
task main()
{
#ifdef WIFI_DEBUGGING
	setBaudRate(UART_PORT, baudRate115200);
	send_debug_msg("Vex Started\n", 13);
	writeDebugStreamLine("%d", nImmediateBatteryLevel);
	while(true)
	{
		if (getChar(UART_PORT) == '1')
		{
			send_debug_msg("Break loop\n", 13);
			direction1 = CLOCKWISE;
			break;
		}
	}
#endif
	while (true)
	{
		//int top_analog = take_average(LEFT_DIST_IR_PORT, 4);
		//int bot_analog = take_average(RIGHT_DIST_IR_PORT, 4);
		//float left_distance = convert_ir_reading_to_distance(LEFT_DIST_IR_TYPE, top_analog) *
		//check_within_range(top_analog, ir_sensor_min_value[(int)LEFT_DIST_IR_TYPE], ir_sensor_max_value[(int)LEFT_DIST_IR_TYPE]);
		//float right_distance = convert_ir_reading_to_distance(RIGHT_DIST_IR_TYPE, bot_analog) *
		//check_within_range(bot_analog, ir_sensor_min_value[(int)RIGHT_DIST_IR_TYPE], ir_sensor_max_value[(int)RIGHT_DIST_IR_TYPE]);
		//writeDebugStreamLine("Top: %f,Btm: %f, Top Dist: %d, Bot Dist: %d", left_distance, right_distance, top_analog, bot_analog);

		//detect_ball_field();
		movement(direction1, 30);
		if (detect_ball_fieldv2())
		{
			direction1 = STOP;
		}
		if (getChar(UART_PORT) == '1')
		{
			direction1 = CLOCKWISE;
		}

		//int door_analog = take_average(DOOR_DIST_IR_PORT, 4);
		//float door_distance = convert_ir_reading_to_distance(DOOR_DIST_IR_TYPE, door_analog);
		//writeDebugStreamLine("Door Dost: %f", door_distance);
		//if (SensorValue(DOOR_LSWITCH_PORT) == 0)
		//{
		//	motor[DOOR_MOT_PORT] = -50;
		//}
		//else
		//{
		//	motor[DOOR_MOT_PORT] = 0;
		//}
		delay(50);
	}
}
